# Excercise Notes

## Get Revenue per Customer using Outer Join

- Get the revenue generated by each customer for the month of 2014 January
- Tables - `orders`, `order_items` and `customers`
- Data should be sorted in descending order by revenue and then ascending order by `customer_id`
- Output should contain `customer_id`, `customer_fname`, `customer_lname`, `customer_revenue`.
- If there are no orders placed by customer, then the corresponding revenue for a given customer should be 0.
- Consider only `COMPLETE` and `CLOSED` orders

```
SELECT c.customer_id,
	c.customer_fname,
	c.customer_lname,
	coalesce(round(sum(oi.order_item_subtotal)::numeric, 2), 0) AS customer_revenue
FROM customers AS c
	LEFT OUTER JOIN orders AS o
		ON o.order_customer_id = c.customer_id
			AND to_char(order_date::timestamp, 'yyyy-MM') = '2014-01'
			AND o.order_status IN ('COMPLETE', 'CLOSED')
	LEFT OUTER JOIN order_items AS oi
		ON o.order_id = oi.order_item_order_id
GROUP BY c.customer_id
ORDER BY customer_revenue DESC, c.customer_id
```

Some new items in this solution:

- **coalesce(arg, null_replacement)**: coalesce() will resolve the given argument, if the result is NULL it will replace it with whatever's in the second argument.

- note how the stack of JOINs works.
    - first we JOIN customers to orders.
        - we add additional arguments to only get the Orders from Jan 2014.
        - we add additional arguments to only get COMPLETE or CLOSED Orders.
    - the LEFT OUTER JOIN means we'll get NULL values for Orders if the Customer didn't place an order that matches our conditions.
    - we add another LEFT OUTER JOIN to get all Order Items (or NULLS) for our constraints.

## Get Revenue per Category

- Get the revenue generated for each category for the month of 2014 January
- Tables - `orders`, `order_items`, `products` and `categories`
- Data should be sorted in ascending order by `category_id`.
- Output should contain all the fields from `categories` along with the revenue as `category_revenue`.
- Consider only `COMPLETE` and `CLOSED` orders

```

```

Get all of the Orders from Jan 2014

```
SELECT * FROM orders
WHERE to_char(order_date::timestamp, 'yyyy-MM') = '2014-01'
```

Get all of the Orders in COMPLETE or CLOSED Status from Jan 2014

```
SELECT * FROM orders
WHERE to_char(order_date::timestamp, 'yyyy-MM') = '2014-01'
AND order_status IN ('COMPLETE', 'CLOSED')
```

Get all of the Order Items that were a part of those ^^ Orders

```
SELECT o.order_id
	FROM orders AS o
		JOIN order_items AS oi
			ON o.order_id = oi.order_item_order_id
			AND to_char(o.order_date::timestamp, 'yyyy-MM') = '2014-01'
			AND o.order_status IN ('COMPLETE', 'CLOSED')
```

Get all of the Product Details for those ^^ Order Items

```
SELECT *
	FROM orders AS o
		JOIN order_items AS oi
			ON o.order_id = oi.order_item_order_id
			AND to_char(o.order_date::timestamp, 'yyyy-MM') = '2014-01'
			AND o.order_status IN ('COMPLETE', 'CLOSED')
		JOIN products AS p
			ON oi.order_item_product_id = p.product_id

```

Get all of the Categories for those ^^ Products

```
SELECT *
	FROM orders AS o
		JOIN order_items AS oi
			ON o.order_id = oi.order_item_order_id
			AND to_char(o.order_date::timestamp, 'yyyy-MM') = '2014-01'
			AND o.order_status IN ('COMPLETE', 'CLOSED')
		JOIN products AS p
			ON oi.order_item_product_id = p.product_id
		JOIN categories AS c
			ON p.product_category_id = c.category_id
```

Get the sum of Order Item Subtotals as category_revenue and GROUP and ORDER BY Category ID

```
SELECT c.*,
	round(sum(oi.order_item_subtotal)::numeric, 2) as category_revenue
	FROM orders AS o
		JOIN order_items AS oi
			ON o.order_id = oi.order_item_order_id
			AND to_char(o.order_date::timestamp, 'yyyy-MM') = '2014-01'
			AND o.order_status IN ('COMPLETE', 'CLOSED')
		JOIN products AS p
			ON oi.order_item_product_id = p.product_id
		JOIN categories AS c
			ON p.product_category_id = c.category_id
GROUP BY c.category_id
ORDER BY c.category_id
```

An alternative solution:

```
SELECT c.*,
	round(sum(oi.order_item_subtotal)::numeric, 2) as category_revenue
	FROM orders AS o
		JOIN order_items AS oi
			ON o.order_id = oi.order_item_order_id
		JOIN products AS p
			ON oi.order_item_product_id = p.product_id
		JOIN categories AS c
			ON p.product_category_id = c.category_id
WHERE to_char(o.order_date::timestamp, 'yyyy-MM') = '2014-01'
	AND o.order_status IN ('COMPLETE', 'CLOSED')
GROUP BY c.category_id
ORDER BY c.category_id
```

The only difference is the location of the WHERE/FILTER conditions. When using INNER JOINS either option is valid. When using OUTER JOINS you may see unexpected results.

## Product Count per Department

- Get the count of products for each department.
- Tables - `departments`, `categories`, `products`
- Data should be sorted in ascending order by `department_id`
- Output should contain all the fields from `departments` and the product count as `product_count`

Get all Departments

``SELECT * FROM departments;``

Get all Categories in those ^^ Departments

```
SELECT *
FROM departments AS d
	JOIN categories AS c
		ON d.department_id = c.category_department_id
```

Get all the Products in those ^^ Categories

```
SELECT *
FROM departments AS d
	JOIN categories AS c
		ON d.department_id = c.category_department_id
	JOIN products AS p
		ON c.category_id = p.product_category_id
```

Get all of the Department fields, count all of the rows as product_count and GROUP BY Department ID. Finally, sort by Department ID.

```
SELECT d.*,
	count(*) as product_count
FROM departments AS d
	JOIN categories AS c
		ON d.department_id = c.category_department_id
	JOIN products AS p
		ON c.category_id = p.product_category_id
GROUP BY d.department_id
ORDER BY d.department_id
```



